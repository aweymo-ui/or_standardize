var store = [ 
    
    
    { 
        "url": "/or_standardize/content/1_intro.html",
        "title": "Introduction",
        "text": "Why OpenRefine Over Google Sheets? While Google Sheets can handle basic find-and-replace or manual editing, OpenRefine offers specialized features for bulk data cleaning and transformation: Clustering Algorithms: OpenRefine uses algorithms to automatically group similar entries that might be misspelled or inconsistently formatted, allowing you to merge them efficiently. Scripted Transformations with GREL: You can write expressions in GREL to transform text in powerful ways that are not available in Google Sheets. Faceting: Facets allow you to view subsets of your data based on specific characteristics. For example, you can filter a column to only show rows with a particular keyword, which helps locate inconsistencies. These features make OpenRefine ideal for cleaning up data quickly and accurately, especially in large datasets where doing this manually would be time-consuming. &#10042; How Clustering Algorithms in OpenRefine Work Clustering algorithms in OpenRefine identify groups of values that are similar but not identical. They rely on techniques that analyze the similarity or distance between different strings, grouping values that meet certain similarity criteria. OpenRefine then allows you to merge these grouped values into a standardized form. Here are the main clustering methods and their underlying principles: Key Collision The Key Collision method is a phonetic algorithm that groups values based on a shared “key.” It essentially tries to ignore minor differences between similar words and considers how they sound, which makes it useful for names or words with common spelling variations. Key Collision Algorithms Fingerprinting: This method is one of the simplest approaches. It: Strips out punctuation and converts all letters to lowercase. Sorts the words alphabetically. Removes duplicates. Creates a “fingerprint” (unique key) from the resulting string. For example, “Mark Twain” and “twain, mark” both result in the fingerprint “mark twain,” grouping these values together. Phonetic Algorithms: Metaphone and Double Metaphone: These algorithms convert words into codes based on how they sound. For example, “Smith” and “Smyth” might be converted into the same phonetic code. Soundex: This groups words with similar sounds. It’s helpful for catching misspellings that still sound correct, though it’s less precise with non-English words. When to Use Key Collision Key Collision works well for fields where phonetic similarities matter, like personal names or locations with alternate spellings (e.g., “New York City” and “N.Y.C.”). &#10042; Nearest Neighbor The Nearest Neighbor method uses a “distance” measure to find strings that are spelled similarly. It’s based on edit distance, meaning it looks at the number of changes needed to transform one string into another. Nearest Neighbor Algorithms Levenshtein Distance: Measures the number of single-character edits (insertions, deletions, or substitutions) required to change one string into another. For example, “color” and “colour” have a small Levenshtein distance because only one letter differs. Jaccard Similarity: Compares the similarity between two sets of characters or words. It’s often used to find matches when there’s a high probability of extra or missing words. PPM (Prediction by Partial Matching): Looks at repeated patterns and attempts to predict similarities based on how often parts of the string match. When to Use Nearest Neighbor Nearest Neighbor is ideal for catching minor typos, misspellings, or small differences in data entries. This is helpful when working with long strings or phrases that might contain small but crucial differences (e.g., “Metropolitan Museum” and “Metropolitan Museum of Art”). &#10042; Choosing Clustering Parameters: Key Collisions vs. Nearest Neighbor In OpenRefine, you’ll often adjust parameters to determine how strict or lenient the clustering is. For example: Distance Threshold (Nearest Neighbor): Lowering the threshold makes clustering more lenient, grouping more items together, while a higher threshold makes it stricter, grouping only very close matches. Normalization (Key Collision): Options like lowercasing and removing whitespace standardize how values are treated, ensuring that “New York” and “new york” are considered the same. Combining Algorithms OpenRefine lets you re-cluster data after merging. For example: You can start with a broad Key Collision method, merging general clusters. Then, apply a Nearest Neighbor method for a more fine-grained cleanup. Example of Using Clustering in OpenRefine Suppose you have a column with author names like “Mark Twain,” “Twain, Mark,” “Mark Twian,” and “M. Twain.” Using the Key Collision clustering method: OpenRefine might group “Mark Twain” and “Twain, Mark” because they sound alike or share a similar fingerprint. Then, using the Nearest Neighbor method: OpenRefine might identify “Mark Twian” as a close match to “Mark Twain” because the edit distance is small. After clustering, you can choose a standardized format (e.g., “Mark Twain”) and apply it across all grouped entries."
    },
    { 
        "url": "/or_standardize/content/2_cluster.html",
        "title": "Importing and Clustering",
        "text": "Install OpenRefine a. Download OpenRefine from openrefine.org for your operating system. b. Install and launch OpenRefine following the instructions provided on the site. OpenRefine will open in your web browser but runs locally on your computer. &#10042; Load Your CSV File a. Click “Create Project” on the OpenRefine homepage. b. Click “Choose Files” and select your CSV file from your computer. c. Press “Next” to load the data. OpenRefine will display a preview of the data for you to verify that it looks correct. d. In the next intermediary screen, adjust character encoding to UTF-8, set column separation to CSV, have the Parse next 1 line as headers selected and adjust the project name as needed. The Store Blank Rows, Store Blank Cells as Nulls and Use Character \" to Enclose Cells Containing Column Separators should be selected by default. These simply ensure data integrity by not erasing null rows and cells and not separating commas within cells, such as Smith, John e. Click “Create Project” to import the data fully. &#10042; Standardization Example To use a practical example for this tutorial, I’ll be using metadata for digital collection of different scholarly publications that needs standardizing. Actions needed: In the creator field, author names need to be standardized and then these names need “last name, first name (or first initial)” formatting In the pubtype field, “Master Gardener” needs to change to “Master Gardener Program Handbook” and “Pacific Northwest Extension” changes to “Pacific Northwest Extension Publications” Subjects field needs to be standardized and verified as Getty standards (CDIL follows Getty, SPECS follows LCHS… might want to sort that out at some point) Publisher field needs basic standardization &#10042; Cluster and Standardize Data Looking first at the creator field, let’s use OpenRefine’s clustering feature to identify and merge similar but non-identical values across a large dataset. Split the Creator Field into Individual Names a. Select the Creator Column: In the column menu for the creator field, click the dropdown. b. Choose “Edit cells” &gt; “Split multi-valued cells…”: Enter ; as the separator to split each name into its own cell within the same column. This will separate names like “Painter, Charles G.; Simpson, William Ray; Parks, F.P.” into three individual rows for each name. Formatting Before we cluster, I am noticing that many of the discrepancies between the author names are due to inconsistent whitespace. To correct these items or adjust for upper / lowercasing inconsistencies: Lowercasing and Removing Whitespace a. In the column menu (e.g., location name), choose “Edit cells” &gt; “Transform…”. b. Enter transformations in GREL (General Refine Expression Language) to standardize formats: To make all entries title case (capitalizing each word): Use value.toTitlecase(). To make entries lowercase: Use value.toLowercase(). To trim extra whitespace: Use value.trim(). Clustering a. Click on the drop-down menu in the column you want to standardize (e.g., author). b. Select “Edit cells” &gt; “Cluster and edit…”. A dialog box will open, showing clusters of similar values. For example, it might group “Mark Twain” and “Twain, Mark” as potential matches. c. Use different clustering methods (key collision, nearest neighbor, etc.) to identify similar entries. Key Collision: Groups based on a phonetic algorithm that ignores small differences. Nearest Neighbor: Groups values based on spelling similarity, which is often helpful for misspelled entries. Merge Back into original cell format a. Review each cluster: If you agree with OpenRefine’s grouping, type in the standardized name you want to use (e.g., “Mark Twain”) in the “New Cell Value” field and click “Merge and Re-Cluster”."
    },
    { 
        "url": "/or_standardize/content/3_format.html",
        "title": "Formatting and Exporting",
        "text": "Standardizing Author Names to “Last Name, First Name” Format To transform names like “First Last” into “Last, First” format, you can use General Refine Expression Language (GREL) to split and reorder the names. Here’s a -by- guide: a. Identify the Author Column: Select the column where author names are listed. b. Create a Text Transformation: Click on the column dropdown menu. Go to “Edit cells” &gt; “Transform…”. c. Enter the Transformation Expression: In the GREL transformation box, enter the following code to split and reorder names: if(value.contains(\" \"), value.split(\" \")[1] + \", \" + value.split(\" \")[0], value) This expression checks if there’s a space in the name (indicating “First Last” format) and then splits the name into first and last. It then reorders it as “Last, First.” Click “OK” to apply the transformation. d. Handling Middle Names or Initials: If you have middle names or initials that need to be preserved, you can use a slightly more advanced expression to handle names with additional components: grel if(value.contains(\" \"), value.split(\" \")[-1] + \", \" + value.split(\" \")[0] + \" \" + value.slice(1,-1).join(\" \"), value) This expression keeps the last name at the beginning, followed by the first name and any middle names or initials. e. Review and Adjust: Review the transformed column for accuracy, especially if there are any entries with unusual name formats. You can manually correct any that don’t fit the standard pattern. &#10042; Standardizing Subject Names to Getty Standards For subject names, ensuring compliance with a controlled vocabulary like the Getty Vocabularies (e.g., Art &amp; Architecture Thesaurus, Thesaurus of Geographic Names) typically involves matching each term to its preferred form in the Getty standards. OpenRefine doesn’t natively support direct access to Getty Vocabularies, but you can still standardize names with a few steps: a. Import a List of Getty-Compliant Terms (Optional): If you have access to a list of Getty-approved terms for your subject field, you can create a CSV or text file with these terms. Import this list into OpenRefine as a new project to use as a reference. b. Use Reconciliation Services: OpenRefine allows you to use reconciliation services to match terms in your dataset to external standards. There are third-party services for various vocabularies, and sometimes institutions make custom reconciliation services available for specific vocabularies. Add a reconciliation service: Go to the Reconciliation tab in OpenRefine. If you have a URL for a reconciliation service that includes Getty terms, you can add it here. This might require some setup or access permissions. c. Match Subject Terms to Getty Standards: If a reconciliation service isn’t available, you can manually compare your subject names against the Getty list by clustering and editing: Clustering: Use Key Collision and Nearest Neighbor clustering to find variants of the same term (e.g., “Photography” vs. “Photographic Arts”). Edit to Getty Standard: For each cluster, standardize the term according to Getty’s preferred term from the reference list. d. Create Custom Transformations (for minor adjustments): If you know certain terms need to be converted (e.g., “Sculpture” should be “Sculpture (visual work)”), you can use Edit cells &gt; Transform… with GREL expressions like: if(value==\"Sculpture\", \"Sculpture (visual work)\", value) Repeat this for any commonly used terms that need to conform to Getty standards. e. Manual Adjustments: Once the bulk of your terms are standardized, review the remaining subject names and manually edit any outliers to match Getty terms. &#10042; &#10042; Export the Standardized Data a. After standardizing both author and subject columns, export your project by going to Export &gt; Comma-separated value (CSV). b. Verify that the standardized data displays correctly in UTF-8 encoding, ensuring consistency and compatibility for CollectionBuilder requirements."
    },
    { 
        "url": "/or_standardize/",
        "title": "Home",
        "text": "CALS Liaison Introduction Contents: Introduction Importing and Clustering Formatting and Exporting Content: CC BY-NC-ND 4.0 Andrew Weymouth 2024 (get source code). Theme: Variation on workshop-template-b by evanwill"
    }];
